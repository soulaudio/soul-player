//! TPDF Dithering for high-quality format conversion
//!
//! Implements Triangular Probability Density Function (TPDF) dithering
//! for converting floating-point audio to integer formats (I16, I32).
//! TPDF is the industry standard for audio dithering.
//!
//! # Why Dithering?
//!
//! When converting from high-precision formats (F32) to lower bit-depths (I16),
//! quantization errors create audible distortion. Adding carefully shaped noise
//! (dither) masks this distortion, resulting in cleaner perceived audio.
//!
//! # Example
//!
//! ```
//! use soul_audio::dither::TpdfDither;
//!
//! let mut dither = TpdfDither::new();
//!
//! // Convert a single sample
//! let sample: f32 = 0.5;
//! let i16_sample = dither.dither_to_i16(sample);
//! ```

/// TPDF (Triangular Probability Density Function) dither
///
/// Uses a Linear Feedback Shift Register (LFSR) for real-time safe
/// random number generation - no heap allocations, no locks.
///
/// TPDF is created by summing two uniform random distributions,
/// resulting in a triangular distribution with optimal noise shaping.
#[derive(Debug)]
pub struct TpdfDither {
    /// LFSR state for pseudo-random number generation
    lfsr_state: u32,
    /// Previous random value for TPDF calculation
    prev_rand: i32,
}

impl TpdfDither {
    /// Create a new TPDF dither with default seed
    pub fn new() -> Self {
        Self {
            lfsr_state: 0xACE1_u32, // Non-zero seed
            prev_rand: 0,
        }
    }

    /// Create with custom seed for reproducible results (useful for testing)
    pub fn with_seed(seed: u32) -> Self {
        Self {
            lfsr_state: if seed == 0 { 1 } else { seed }, // Avoid zero state
            prev_rand: 0,
        }
    }

    /// Generate next LFSR value (Galois LFSR, maximal period 2^32-1)
    ///
    /// This is a real-time safe random number generator:
    /// - No heap allocation
    /// - No locks or system calls
    /// - Constant time execution
    #[inline(always)]
    fn next_lfsr(&mut self) -> u32 {
        // Galois LFSR with polynomial x^32 + x^22 + x^2 + x^1 + 1
        // This gives a maximal period of 2^32 - 1
        let lsb = self.lfsr_state & 1;
        self.lfsr_state >>= 1;
        if lsb == 1 {
            self.lfsr_state ^= 0xD000_0001; // Feedback polynomial
        }
        self.lfsr_state
    }

    /// Generate TPDF noise in range [-1.0, 1.0]
    ///
    /// TPDF is generated by summing two uniform distributions,
    /// which creates a triangular PDF with zero mean.
    #[inline(always)]
    fn tpdf_noise_i16(&mut self) -> i32 {
        // Get two uniform random values and sum them for TPDF
        let rand1 = (self.next_lfsr() >> 16) as i32 - 32768;
        let rand2 = self.prev_rand;
        self.prev_rand = rand1;

        // Sum gives triangular distribution, scaled for 16-bit
        // Range: [-1, 1] in 16-bit quantization steps
        rand1 - rand2
    }

    /// Generate TPDF noise for 24-bit depth (I32 with 24-bit precision)
    #[inline(always)]
    fn tpdf_noise_i24(&mut self) -> i32 {
        // For 24-bit, we need more precision in the noise
        let rand1 = (self.next_lfsr() >> 8) as i32 - 8388608;
        let rand2 = self.prev_rand;
        self.prev_rand = rand1;

        // Scale for 24-bit (8-bit shift for the 24->32 padding)
        (rand1 - rand2) >> 8
    }

    /// Convert F32 sample to I16 with TPDF dithering
    ///
    /// # Arguments
    /// * `sample` - Input sample in range [-1.0, 1.0]
    ///
    /// # Returns
    /// Dithered 16-bit sample
    #[inline]
    pub fn dither_to_i16(&mut self, sample: f32) -> i16 {
        // Scale to 16-bit range
        let scaled = sample * 32767.0;

        // Add TPDF noise (±1 LSB triangular)
        let noise = self.tpdf_noise_i16();
        let dithered = scaled + (noise as f32 / 65536.0);

        // Round and clamp
        dithered.round().clamp(-32768.0, 32767.0) as i16
    }

    /// Convert F32 sample to I32 with TPDF dithering (24-bit precision)
    ///
    /// Most I32 audio is actually 24-bit in a 32-bit container.
    /// This applies dithering appropriate for 24-bit precision.
    ///
    /// # Arguments
    /// * `sample` - Input sample in range [-1.0, 1.0]
    ///
    /// # Returns
    /// Dithered 32-bit sample (24-bit precision)
    #[inline]
    pub fn dither_to_i32(&mut self, sample: f32) -> i32 {
        // Scale to 32-bit range
        let scaled = sample as f64 * 2147483647.0;

        // Add TPDF noise for 24-bit depth
        let noise = self.tpdf_noise_i24();
        let dithered = scaled + noise as f64;

        // Round and clamp
        dithered.round().clamp(-2147483648.0, 2147483647.0) as i32
    }

    /// Convert F32 sample to I32 without dithering (for true 32-bit output)
    ///
    /// Use this for 32-bit float to 32-bit integer conversion where
    /// the full 32-bit precision is needed (rare in audio).
    #[inline]
    pub fn convert_to_i32_no_dither(sample: f32) -> i32 {
        let scaled = sample as f64 * 2147483647.0;
        scaled.round().clamp(-2147483648.0, 2147483647.0) as i32
    }

    /// Process an entire buffer, converting F32 to I16 with TPDF dithering
    ///
    /// # Arguments
    /// * `input` - Input buffer of F32 samples
    /// * `output` - Output buffer for I16 samples (must be same length)
    pub fn process_to_i16(&mut self, input: &[f32], output: &mut [i16]) {
        debug_assert_eq!(input.len(), output.len());
        for (inp, out) in input.iter().zip(output.iter_mut()) {
            *out = self.dither_to_i16(*inp);
        }
    }

    /// Process an entire buffer, converting F32 to I32 with TPDF dithering
    ///
    /// # Arguments
    /// * `input` - Input buffer of F32 samples
    /// * `output` - Output buffer for I32 samples (must be same length)
    pub fn process_to_i32(&mut self, input: &[f32], output: &mut [i32]) {
        debug_assert_eq!(input.len(), output.len());
        for (inp, out) in input.iter().zip(output.iter_mut()) {
            *out = self.dither_to_i32(*inp);
        }
    }

    /// Reset the dither state
    ///
    /// Call between tracks for consistent behavior,
    /// though not strictly necessary.
    pub fn reset(&mut self) {
        self.lfsr_state = 0xACE1_u32;
        self.prev_rand = 0;
    }
}

impl Default for TpdfDither {
    fn default() -> Self {
        Self::new()
    }
}

impl Clone for TpdfDither {
    fn clone(&self) -> Self {
        // Clone with a different seed to avoid correlated noise
        // between instances (important for stereo processing)
        Self {
            lfsr_state: self.lfsr_state.wrapping_mul(1103515245).wrapping_add(12345),
            prev_rand: 0,
        }
    }
}

/// Stereo dither for processing interleaved audio
///
/// Uses independent dither states for L/R channels to avoid
/// correlated noise that could cause phantom center artifacts.
#[derive(Debug, Clone)]
pub struct StereoDither {
    left: TpdfDither,
    right: TpdfDither,
}

impl StereoDither {
    /// Create a new stereo dither
    pub fn new() -> Self {
        Self {
            left: TpdfDither::new(),
            right: TpdfDither::with_seed(0x5EED_u32), // Different seed for decorrelation
        }
    }

    /// Process interleaved stereo F32 to I16
    ///
    /// # Arguments
    /// * `input` - Interleaved stereo F32 samples [L, R, L, R, ...]
    /// * `output` - Output buffer for I16 samples (same length)
    pub fn process_stereo_to_i16(&mut self, input: &[f32], output: &mut [i16]) {
        debug_assert_eq!(input.len(), output.len());
        debug_assert_eq!(input.len() % 2, 0);

        for i in (0..input.len()).step_by(2) {
            output[i] = self.left.dither_to_i16(input[i]);
            output[i + 1] = self.right.dither_to_i16(input[i + 1]);
        }
    }

    /// Process interleaved stereo F32 to I32
    pub fn process_stereo_to_i32(&mut self, input: &[f32], output: &mut [i32]) {
        debug_assert_eq!(input.len(), output.len());
        debug_assert_eq!(input.len() % 2, 0);

        for i in (0..input.len()).step_by(2) {
            output[i] = self.left.dither_to_i32(input[i]);
            output[i + 1] = self.right.dither_to_i32(input[i + 1]);
        }
    }

    /// Reset both channels
    pub fn reset(&mut self) {
        self.left.reset();
        self.right.reset();
    }
}

impl Default for StereoDither {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dither_creation() {
        let dither = TpdfDither::new();
        assert_ne!(dither.lfsr_state, 0);
    }

    #[test]
    fn test_dither_to_i16_range() {
        let mut dither = TpdfDither::new();

        // Test various input values
        let samples = [0.0, 0.5, -0.5, 1.0, -1.0, 0.999, -0.999];
        for sample in samples {
            let result = dither.dither_to_i16(sample);
            assert!(
                result >= i16::MIN && result <= i16::MAX,
                "Sample {} produced out of range result {}",
                sample,
                result
            );
        }
    }

    #[test]
    fn test_dither_to_i16_clipping() {
        let mut dither = TpdfDither::new();

        // Values beyond ±1.0 should be clipped
        assert!(dither.dither_to_i16(2.0) <= i16::MAX);
        assert!(dither.dither_to_i16(-2.0) >= i16::MIN);
    }

    #[test]
    fn test_dither_to_i32_range() {
        let mut dither = TpdfDither::new();

        let samples = [0.0, 0.5, -0.5, 1.0, -1.0];
        for sample in samples {
            let result = dither.dither_to_i32(sample);
            // Just verify no panic, range is always valid for i32
            assert!(result >= i32::MIN && result <= i32::MAX);
        }
    }

    #[test]
    fn test_dither_reproducibility() {
        let mut dither1 = TpdfDither::with_seed(12345);
        let mut dither2 = TpdfDither::with_seed(12345);

        // Same seed should produce same sequence
        for _ in 0..100 {
            let r1 = dither1.dither_to_i16(0.5);
            let r2 = dither2.dither_to_i16(0.5);
            assert_eq!(r1, r2);
        }
    }

    #[test]
    fn test_stereo_dither_decorrelation() {
        let mut stereo = StereoDither::new();

        // L and R channels should have different noise patterns
        // We test with a mid-range value where noise variance is visible
        let mut noise_l: Vec<i16> = Vec::with_capacity(1000);
        let mut noise_r: Vec<i16> = Vec::with_capacity(1000);

        // Use a consistent test value - the noise should be uncorrelated
        let test_value = 0.5_f32;

        for _ in 0..1000 {
            noise_l.push(stereo.left.dither_to_i16(test_value));
            noise_r.push(stereo.right.dither_to_i16(test_value));
        }

        // Check that L and R noise patterns are different
        // by computing the correlation coefficient
        let mean_l: f64 = noise_l.iter().map(|&x| x as f64).sum::<f64>() / 1000.0;
        let mean_r: f64 = noise_r.iter().map(|&x| x as f64).sum::<f64>() / 1000.0;

        let mut covariance = 0.0_f64;
        let mut var_l = 0.0_f64;
        let mut var_r = 0.0_f64;

        for i in 0..1000 {
            let dl = noise_l[i] as f64 - mean_l;
            let dr = noise_r[i] as f64 - mean_r;
            covariance += dl * dr;
            var_l += dl * dl;
            var_r += dr * dr;
        }

        let correlation = if var_l > 0.0 && var_r > 0.0 {
            covariance / (var_l.sqrt() * var_r.sqrt())
        } else {
            0.0
        };

        // Correlation should be low (uncorrelated noise) - typically < 0.1
        assert!(
            correlation.abs() < 0.15,
            "L/R noise too correlated: {:.4}",
            correlation
        );
    }

    #[test]
    fn test_process_buffer() {
        let mut dither = TpdfDither::new();
        let input = [0.5_f32; 100];
        let mut output = [0_i16; 100];

        dither.process_to_i16(&input, &mut output);

        // All outputs should be around 16384 (0.5 * 32767)
        for &sample in &output {
            assert!(
                (sample as i32 - 16384).abs() < 100,
                "Unexpected sample value: {}",
                sample
            );
        }
    }

    #[test]
    fn test_tpdf_distribution() {
        // TPDF should have zero mean and triangular distribution
        let mut dither = TpdfDither::new();
        let mut sum: i64 = 0;

        // Generate many samples at 0.0 to analyze noise distribution
        for _ in 0..100_000 {
            let sample = dither.dither_to_i16(0.0);
            sum += sample as i64;
        }

        // Mean should be close to zero
        let mean = sum as f64 / 100_000.0;
        assert!(
            mean.abs() < 10.0,
            "Mean too far from zero: {}",
            mean
        );
    }

    #[test]
    fn test_stereo_buffer_processing() {
        let mut stereo = StereoDither::new();
        let input = vec![0.5_f32; 200]; // 100 stereo frames
        let mut output = vec![0_i16; 200];

        stereo.process_stereo_to_i16(&input, &mut output);

        // Verify all samples are reasonable
        for &sample in &output {
            assert!(
                (sample as i32 - 16384).abs() < 100,
                "Unexpected sample: {}",
                sample
            );
        }
    }
}
